// Code generated by protoc-gen-go. DO NOT EDIT.
// source: snomed.proto

package snomed

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Expression_DefinitionStatus int32

const (
	Expression_EQUIVALENT_TO Expression_DefinitionStatus = 0
	Expression_SUBTYPE_OF    Expression_DefinitionStatus = 1
)

var Expression_DefinitionStatus_name = map[int32]string{
	0: "EQUIVALENT_TO",
	1: "SUBTYPE_OF",
}
var Expression_DefinitionStatus_value = map[string]int32{
	"EQUIVALENT_TO": 0,
	"SUBTYPE_OF":    1,
}

func (x Expression_DefinitionStatus) String() string {
	return proto.EnumName(Expression_DefinitionStatus_name, int32(x))
}
func (Expression_DefinitionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{12, 0}
}

type SubsumptionResponse_Result int32

const (
	SubsumptionResponse_EQUIVALENT   SubsumptionResponse_Result = 0
	SubsumptionResponse_SUBSUMES     SubsumptionResponse_Result = 1
	SubsumptionResponse_SUBSUMED_BY  SubsumptionResponse_Result = 2
	SubsumptionResponse_NOT_SUBSUMED SubsumptionResponse_Result = 3
)

var SubsumptionResponse_Result_name = map[int32]string{
	0: "EQUIVALENT",
	1: "SUBSUMES",
	2: "SUBSUMED_BY",
	3: "NOT_SUBSUMED",
}
var SubsumptionResponse_Result_value = map[string]int32{
	"EQUIVALENT":   0,
	"SUBSUMES":     1,
	"SUBSUMED_BY":  2,
	"NOT_SUBSUMED": 3,
}

func (x SubsumptionResponse_Result) String() string {
	return proto.EnumName(SubsumptionResponse_Result_name, int32(x))
}
func (SubsumptionResponse_Result) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{14, 0}
}

type SearchRequest_Fuzzy int32

const (
	SearchRequest_FALLBACK_FUZZY SearchRequest_Fuzzy = 0
	SearchRequest_ALWAYS_FUZZY   SearchRequest_Fuzzy = 1
	SearchRequest_NO_FUZZY       SearchRequest_Fuzzy = 2
)

var SearchRequest_Fuzzy_name = map[int32]string{
	0: "FALLBACK_FUZZY",
	1: "ALWAYS_FUZZY",
	2: "NO_FUZZY",
}
var SearchRequest_Fuzzy_value = map[string]int32{
	"FALLBACK_FUZZY": 0,
	"ALWAYS_FUZZY":   1,
	"NO_FUZZY":       2,
}

func (x SearchRequest_Fuzzy) String() string {
	return proto.EnumName(SearchRequest_Fuzzy_name, int32(x))
}
func (SearchRequest_Fuzzy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{18, 0}
}

// A Concept represents a SNOMED-CT concept.
// The RF2 release allows multiple duplicate entries per concept identifier to permit versioning.
// As such, we have a compound primary key made up of the concept identifier and the effective time.
// Only one concept with a specified identifier will be active at any time point.
// See https://confluence.ihtsdotools.org/display/DOCRELFMT/3.2.1.+Concept+File+Specification
type Concept struct {
	Id                   int64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	EffectiveTime        *timestamp.Timestamp `protobuf:"bytes,2,opt,name=effective_time,json=effectiveTime,proto3" json:"effective_time,omitempty"`
	Active               bool                 `protobuf:"varint,3,opt,name=active,proto3" json:"active,omitempty"`
	ModuleId             int64                `protobuf:"varint,4,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	DefinitionStatusId   int64                `protobuf:"varint,5,opt,name=definition_status_id,json=definitionStatusId,proto3" json:"definition_status_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Concept) Reset()         { *m = Concept{} }
func (m *Concept) String() string { return proto.CompactTextString(m) }
func (*Concept) ProtoMessage()    {}
func (*Concept) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{0}
}
func (m *Concept) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Concept.Unmarshal(m, b)
}
func (m *Concept) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Concept.Marshal(b, m, deterministic)
}
func (dst *Concept) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Concept.Merge(dst, src)
}
func (m *Concept) XXX_Size() int {
	return xxx_messageInfo_Concept.Size(m)
}
func (m *Concept) XXX_DiscardUnknown() {
	xxx_messageInfo_Concept.DiscardUnknown(m)
}

var xxx_messageInfo_Concept proto.InternalMessageInfo

func (m *Concept) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Concept) GetEffectiveTime() *timestamp.Timestamp {
	if m != nil {
		return m.EffectiveTime
	}
	return nil
}

func (m *Concept) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Concept) GetModuleId() int64 {
	if m != nil {
		return m.ModuleId
	}
	return 0
}

func (m *Concept) GetDefinitionStatusId() int64 {
	if m != nil {
		return m.DefinitionStatusId
	}
	return 0
}

// A Description holds descriptions that describe SNOMED CT concepts.
// A description is used to give meaning to a concept and provide well-understood and standard ways of referring to a concept.
// See https://confluence.ihtsdotools.org/display/DOCRELFMT/3.2.2.+Description+File+Specification
type Description struct {
	Id                   int64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	EffectiveTime        *timestamp.Timestamp `protobuf:"bytes,2,opt,name=effective_time,json=effectiveTime,proto3" json:"effective_time,omitempty"`
	Active               bool                 `protobuf:"varint,3,opt,name=active,proto3" json:"active,omitempty"`
	ModuleId             int64                `protobuf:"varint,4,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	ConceptId            int64                `protobuf:"varint,5,opt,name=concept_id,json=conceptId,proto3" json:"concept_id,omitempty"`
	LanguageCode         string               `protobuf:"bytes,6,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
	TypeId               int64                `protobuf:"varint,7,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	Term                 string               `protobuf:"bytes,8,opt,name=term,proto3" json:"term,omitempty"`
	CaseSignificance     int64                `protobuf:"varint,9,opt,name=case_significance,json=caseSignificance,proto3" json:"case_significance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Description) Reset()         { *m = Description{} }
func (m *Description) String() string { return proto.CompactTextString(m) }
func (*Description) ProtoMessage()    {}
func (*Description) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{1}
}
func (m *Description) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Description.Unmarshal(m, b)
}
func (m *Description) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Description.Marshal(b, m, deterministic)
}
func (dst *Description) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Description.Merge(dst, src)
}
func (m *Description) XXX_Size() int {
	return xxx_messageInfo_Description.Size(m)
}
func (m *Description) XXX_DiscardUnknown() {
	xxx_messageInfo_Description.DiscardUnknown(m)
}

var xxx_messageInfo_Description proto.InternalMessageInfo

func (m *Description) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Description) GetEffectiveTime() *timestamp.Timestamp {
	if m != nil {
		return m.EffectiveTime
	}
	return nil
}

func (m *Description) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Description) GetModuleId() int64 {
	if m != nil {
		return m.ModuleId
	}
	return 0
}

func (m *Description) GetConceptId() int64 {
	if m != nil {
		return m.ConceptId
	}
	return 0
}

func (m *Description) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

func (m *Description) GetTypeId() int64 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *Description) GetTerm() string {
	if m != nil {
		return m.Term
	}
	return ""
}

func (m *Description) GetCaseSignificance() int64 {
	if m != nil {
		return m.CaseSignificance
	}
	return 0
}

// Relationship defines a relationship between two concepts as a type itself defined as a concept
type Relationship struct {
	Id                   int64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	EffectiveTime        *timestamp.Timestamp `protobuf:"bytes,2,opt,name=effective_time,json=effectiveTime,proto3" json:"effective_time,omitempty"`
	Active               bool                 `protobuf:"varint,3,opt,name=active,proto3" json:"active,omitempty"`
	ModuleId             int64                `protobuf:"varint,4,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	SourceId             int64                `protobuf:"varint,5,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
	DestinationId        int64                `protobuf:"varint,6,opt,name=destination_id,json=destinationId,proto3" json:"destination_id,omitempty"`
	RelationshipGroup    int64                `protobuf:"varint,7,opt,name=relationship_group,json=relationshipGroup,proto3" json:"relationship_group,omitempty"`
	TypeId               int64                `protobuf:"varint,8,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	CharacteristicTypeId int64                `protobuf:"varint,9,opt,name=characteristic_type_id,json=characteristicTypeId,proto3" json:"characteristic_type_id,omitempty"`
	ModifierId           int64                `protobuf:"varint,10,opt,name=modifier_id,json=modifierId,proto3" json:"modifier_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Relationship) Reset()         { *m = Relationship{} }
func (m *Relationship) String() string { return proto.CompactTextString(m) }
func (*Relationship) ProtoMessage()    {}
func (*Relationship) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{2}
}
func (m *Relationship) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Relationship.Unmarshal(m, b)
}
func (m *Relationship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Relationship.Marshal(b, m, deterministic)
}
func (dst *Relationship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relationship.Merge(dst, src)
}
func (m *Relationship) XXX_Size() int {
	return xxx_messageInfo_Relationship.Size(m)
}
func (m *Relationship) XXX_DiscardUnknown() {
	xxx_messageInfo_Relationship.DiscardUnknown(m)
}

var xxx_messageInfo_Relationship proto.InternalMessageInfo

func (m *Relationship) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Relationship) GetEffectiveTime() *timestamp.Timestamp {
	if m != nil {
		return m.EffectiveTime
	}
	return nil
}

func (m *Relationship) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Relationship) GetModuleId() int64 {
	if m != nil {
		return m.ModuleId
	}
	return 0
}

func (m *Relationship) GetSourceId() int64 {
	if m != nil {
		return m.SourceId
	}
	return 0
}

func (m *Relationship) GetDestinationId() int64 {
	if m != nil {
		return m.DestinationId
	}
	return 0
}

func (m *Relationship) GetRelationshipGroup() int64 {
	if m != nil {
		return m.RelationshipGroup
	}
	return 0
}

func (m *Relationship) GetTypeId() int64 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *Relationship) GetCharacteristicTypeId() int64 {
	if m != nil {
		return m.CharacteristicTypeId
	}
	return 0
}

func (m *Relationship) GetModifierId() int64 {
	if m != nil {
		return m.ModifierId
	}
	return 0
}

// ReferenceSet support customization and enhancement of SNOMED CT content. These include representation of subsets,
// language preferences maps for or from other code systems.
// There are multiple reference set types which extend this structure
// In the specification, the referenced component ID can be a SCT identifier or a UUID which is... problematic.
// In this structure, the referenced component ID is a SCT identifier... only. For now.
// Fortunately, in concrete types of reference set ("patterns"), it is made explicit.
type ReferenceSetItem struct {
	Id                    string               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	EffectiveTime         *timestamp.Timestamp `protobuf:"bytes,2,opt,name=effective_time,json=effectiveTime,proto3" json:"effective_time,omitempty"`
	Active                bool                 `protobuf:"varint,3,opt,name=active,proto3" json:"active,omitempty"`
	ModuleId              int64                `protobuf:"varint,4,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	RefsetId              int64                `protobuf:"varint,5,opt,name=refset_id,json=refsetId,proto3" json:"refset_id,omitempty"`
	ReferencedComponentId int64                `protobuf:"varint,6,opt,name=referenced_component_id,json=referencedComponentId,proto3" json:"referenced_component_id,omitempty"`
	// Types that are valid to be assigned to Body:
	//	*ReferenceSetItem_RefsetDescriptor
	//	*ReferenceSetItem_Simple
	//	*ReferenceSetItem_Language
	//	*ReferenceSetItem_SimpleMap
	//	*ReferenceSetItem_ComplexMap
	Body                 isReferenceSetItem_Body `protobuf_oneof:"body"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ReferenceSetItem) Reset()         { *m = ReferenceSetItem{} }
func (m *ReferenceSetItem) String() string { return proto.CompactTextString(m) }
func (*ReferenceSetItem) ProtoMessage()    {}
func (*ReferenceSetItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{3}
}
func (m *ReferenceSetItem) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReferenceSetItem.Unmarshal(m, b)
}
func (m *ReferenceSetItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReferenceSetItem.Marshal(b, m, deterministic)
}
func (dst *ReferenceSetItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReferenceSetItem.Merge(dst, src)
}
func (m *ReferenceSetItem) XXX_Size() int {
	return xxx_messageInfo_ReferenceSetItem.Size(m)
}
func (m *ReferenceSetItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ReferenceSetItem.DiscardUnknown(m)
}

var xxx_messageInfo_ReferenceSetItem proto.InternalMessageInfo

type isReferenceSetItem_Body interface {
	isReferenceSetItem_Body()
}

type ReferenceSetItem_RefsetDescriptor struct {
	RefsetDescriptor *RefSetDescriptorReferenceSet `protobuf:"bytes,7,opt,name=refset_descriptor,json=refsetDescriptor,proto3,oneof"`
}
type ReferenceSetItem_Simple struct {
	Simple *SimpleReferenceSet `protobuf:"bytes,8,opt,name=simple,proto3,oneof"`
}
type ReferenceSetItem_Language struct {
	Language *LanguageReferenceSet `protobuf:"bytes,9,opt,name=language,proto3,oneof"`
}
type ReferenceSetItem_SimpleMap struct {
	SimpleMap *SimpleMapReferenceSet `protobuf:"bytes,10,opt,name=simple_map,json=simpleMap,proto3,oneof"`
}
type ReferenceSetItem_ComplexMap struct {
	ComplexMap *ComplexMapReferenceSet `protobuf:"bytes,11,opt,name=complex_map,json=complexMap,proto3,oneof"`
}

func (*ReferenceSetItem_RefsetDescriptor) isReferenceSetItem_Body() {}
func (*ReferenceSetItem_Simple) isReferenceSetItem_Body()           {}
func (*ReferenceSetItem_Language) isReferenceSetItem_Body()         {}
func (*ReferenceSetItem_SimpleMap) isReferenceSetItem_Body()        {}
func (*ReferenceSetItem_ComplexMap) isReferenceSetItem_Body()       {}

func (m *ReferenceSetItem) GetBody() isReferenceSetItem_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ReferenceSetItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ReferenceSetItem) GetEffectiveTime() *timestamp.Timestamp {
	if m != nil {
		return m.EffectiveTime
	}
	return nil
}

func (m *ReferenceSetItem) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ReferenceSetItem) GetModuleId() int64 {
	if m != nil {
		return m.ModuleId
	}
	return 0
}

func (m *ReferenceSetItem) GetRefsetId() int64 {
	if m != nil {
		return m.RefsetId
	}
	return 0
}

func (m *ReferenceSetItem) GetReferencedComponentId() int64 {
	if m != nil {
		return m.ReferencedComponentId
	}
	return 0
}

func (m *ReferenceSetItem) GetRefsetDescriptor() *RefSetDescriptorReferenceSet {
	if x, ok := m.GetBody().(*ReferenceSetItem_RefsetDescriptor); ok {
		return x.RefsetDescriptor
	}
	return nil
}

func (m *ReferenceSetItem) GetSimple() *SimpleReferenceSet {
	if x, ok := m.GetBody().(*ReferenceSetItem_Simple); ok {
		return x.Simple
	}
	return nil
}

func (m *ReferenceSetItem) GetLanguage() *LanguageReferenceSet {
	if x, ok := m.GetBody().(*ReferenceSetItem_Language); ok {
		return x.Language
	}
	return nil
}

func (m *ReferenceSetItem) GetSimpleMap() *SimpleMapReferenceSet {
	if x, ok := m.GetBody().(*ReferenceSetItem_SimpleMap); ok {
		return x.SimpleMap
	}
	return nil
}

func (m *ReferenceSetItem) GetComplexMap() *ComplexMapReferenceSet {
	if x, ok := m.GetBody().(*ReferenceSetItem_ComplexMap); ok {
		return x.ComplexMap
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReferenceSetItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReferenceSetItem_OneofMarshaler, _ReferenceSetItem_OneofUnmarshaler, _ReferenceSetItem_OneofSizer, []interface{}{
		(*ReferenceSetItem_RefsetDescriptor)(nil),
		(*ReferenceSetItem_Simple)(nil),
		(*ReferenceSetItem_Language)(nil),
		(*ReferenceSetItem_SimpleMap)(nil),
		(*ReferenceSetItem_ComplexMap)(nil),
	}
}

func _ReferenceSetItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReferenceSetItem)
	// body
	switch x := m.Body.(type) {
	case *ReferenceSetItem_RefsetDescriptor:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RefsetDescriptor); err != nil {
			return err
		}
	case *ReferenceSetItem_Simple:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Simple); err != nil {
			return err
		}
	case *ReferenceSetItem_Language:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Language); err != nil {
			return err
		}
	case *ReferenceSetItem_SimpleMap:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleMap); err != nil {
			return err
		}
	case *ReferenceSetItem_ComplexMap:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ComplexMap); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReferenceSetItem.Body has unexpected type %T", x)
	}
	return nil
}

func _ReferenceSetItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReferenceSetItem)
	switch tag {
	case 7: // body.refset_descriptor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RefSetDescriptorReferenceSet)
		err := b.DecodeMessage(msg)
		m.Body = &ReferenceSetItem_RefsetDescriptor{msg}
		return true, err
	case 8: // body.simple
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SimpleReferenceSet)
		err := b.DecodeMessage(msg)
		m.Body = &ReferenceSetItem_Simple{msg}
		return true, err
	case 9: // body.language
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LanguageReferenceSet)
		err := b.DecodeMessage(msg)
		m.Body = &ReferenceSetItem_Language{msg}
		return true, err
	case 10: // body.simple_map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SimpleMapReferenceSet)
		err := b.DecodeMessage(msg)
		m.Body = &ReferenceSetItem_SimpleMap{msg}
		return true, err
	case 11: // body.complex_map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ComplexMapReferenceSet)
		err := b.DecodeMessage(msg)
		m.Body = &ReferenceSetItem_ComplexMap{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReferenceSetItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReferenceSetItem)
	// body
	switch x := m.Body.(type) {
	case *ReferenceSetItem_RefsetDescriptor:
		s := proto.Size(x.RefsetDescriptor)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReferenceSetItem_Simple:
		s := proto.Size(x.Simple)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReferenceSetItem_Language:
		s := proto.Size(x.Language)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReferenceSetItem_SimpleMap:
		s := proto.Size(x.SimpleMap)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReferenceSetItem_ComplexMap:
		s := proto.Size(x.ComplexMap)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RefSetDescriptorReferenceSet is a type of reference set that provides information about a different reference set
// See https://confluence.ihtsdotools.org/display/DOCRELFMT/4.2.11.+Reference+Set+Descriptor
// It provides the additional structure for a given reference set.
type RefSetDescriptorReferenceSet struct {
	AttributeDescriptionId int64    `protobuf:"varint,1,opt,name=attribute_description_id,json=attributeDescriptionId,proto3" json:"attribute_description_id,omitempty"`
	AttributeTypeId        int64    `protobuf:"varint,2,opt,name=attribute_type_id,json=attributeTypeId,proto3" json:"attribute_type_id,omitempty"`
	AttributeOrder         uint32   `protobuf:"varint,3,opt,name=attribute_order,json=attributeOrder,proto3" json:"attribute_order,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *RefSetDescriptorReferenceSet) Reset()         { *m = RefSetDescriptorReferenceSet{} }
func (m *RefSetDescriptorReferenceSet) String() string { return proto.CompactTextString(m) }
func (*RefSetDescriptorReferenceSet) ProtoMessage()    {}
func (*RefSetDescriptorReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{4}
}
func (m *RefSetDescriptorReferenceSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RefSetDescriptorReferenceSet.Unmarshal(m, b)
}
func (m *RefSetDescriptorReferenceSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RefSetDescriptorReferenceSet.Marshal(b, m, deterministic)
}
func (dst *RefSetDescriptorReferenceSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefSetDescriptorReferenceSet.Merge(dst, src)
}
func (m *RefSetDescriptorReferenceSet) XXX_Size() int {
	return xxx_messageInfo_RefSetDescriptorReferenceSet.Size(m)
}
func (m *RefSetDescriptorReferenceSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RefSetDescriptorReferenceSet.DiscardUnknown(m)
}

var xxx_messageInfo_RefSetDescriptorReferenceSet proto.InternalMessageInfo

func (m *RefSetDescriptorReferenceSet) GetAttributeDescriptionId() int64 {
	if m != nil {
		return m.AttributeDescriptionId
	}
	return 0
}

func (m *RefSetDescriptorReferenceSet) GetAttributeTypeId() int64 {
	if m != nil {
		return m.AttributeTypeId
	}
	return 0
}

func (m *RefSetDescriptorReferenceSet) GetAttributeOrder() uint32 {
	if m != nil {
		return m.AttributeOrder
	}
	return 0
}

// SimpleReferenceSet is a simple reference set usable for defining subsets
// See https://confluence.ihtsdotools.org/display/DOCRELFMT/4.2.1.+Simple+Reference+Set
type SimpleReferenceSet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleReferenceSet) Reset()         { *m = SimpleReferenceSet{} }
func (m *SimpleReferenceSet) String() string { return proto.CompactTextString(m) }
func (*SimpleReferenceSet) ProtoMessage()    {}
func (*SimpleReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{5}
}
func (m *SimpleReferenceSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SimpleReferenceSet.Unmarshal(m, b)
}
func (m *SimpleReferenceSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SimpleReferenceSet.Marshal(b, m, deterministic)
}
func (dst *SimpleReferenceSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleReferenceSet.Merge(dst, src)
}
func (m *SimpleReferenceSet) XXX_Size() int {
	return xxx_messageInfo_SimpleReferenceSet.Size(m)
}
func (m *SimpleReferenceSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleReferenceSet.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleReferenceSet proto.InternalMessageInfo

// LanguageReferenceSet is a A 900000000000506000 |Language type reference set| supporting the representation of
// language and dialects preferences for the use of particular descriptions.
// "The most common use case for this type of reference set is to specify the acceptable and preferred terms
// for use within a particular country or region. However, the same type of reference set can also be used to
// represent preferences for use of descriptions in a more specific context such as a clinical specialty,
// organization or department.
//
// No more than one description of a specific description type associated with a single concept may have the acceptabilityId value 900000000000548007 |Preferred|.
// Every active concept should have one preferred synonym in each language.
// This means that a language reference set should assign the acceptabilityId  900000000000548007 |Preferred|  to one  synonym (a  description with  typeId value 900000000000013009 |synonym|) associated with each concept .
// This description is the preferred term for that concept in the specified language or dialect.
// Any  description which is not referenced by an active row in the   reference set is regarded as unacceptable (i.e. not a valid  synonym in the language or  dialect ).
// If a description becomes unacceptable, the relevant language reference set member is inactivated by adding a new row with the same id, the effectiveTime of the the change and the value active=0.
// For this reason there is no requirement for an "unacceptable" value."
// See https://confluence.ihtsdotools.org/display/DOCRELFMT/4.2.4.+Language+Reference+Set
//
type LanguageReferenceSet struct {
	AcceptabilityId      int64    `protobuf:"varint,1,opt,name=acceptability_id,json=acceptabilityId,proto3" json:"acceptability_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LanguageReferenceSet) Reset()         { *m = LanguageReferenceSet{} }
func (m *LanguageReferenceSet) String() string { return proto.CompactTextString(m) }
func (*LanguageReferenceSet) ProtoMessage()    {}
func (*LanguageReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{6}
}
func (m *LanguageReferenceSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LanguageReferenceSet.Unmarshal(m, b)
}
func (m *LanguageReferenceSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LanguageReferenceSet.Marshal(b, m, deterministic)
}
func (dst *LanguageReferenceSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LanguageReferenceSet.Merge(dst, src)
}
func (m *LanguageReferenceSet) XXX_Size() int {
	return xxx_messageInfo_LanguageReferenceSet.Size(m)
}
func (m *LanguageReferenceSet) XXX_DiscardUnknown() {
	xxx_messageInfo_LanguageReferenceSet.DiscardUnknown(m)
}

var xxx_messageInfo_LanguageReferenceSet proto.InternalMessageInfo

func (m *LanguageReferenceSet) GetAcceptabilityId() int64 {
	if m != nil {
		return m.AcceptabilityId
	}
	return 0
}

// SimpleMapReferenceSet is a straightforward one-to-one map between SNOMED-CT concepts and another
// coding system. This is appropriate for simple maps.
// See https://confluence.ihtsdotools.org/display/DOCRELFMT/4.2.9.+Simple+Map+Reference+Set
type SimpleMapReferenceSet struct {
	MapTarget            string   `protobuf:"bytes,1,opt,name=map_target,json=mapTarget,proto3" json:"map_target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleMapReferenceSet) Reset()         { *m = SimpleMapReferenceSet{} }
func (m *SimpleMapReferenceSet) String() string { return proto.CompactTextString(m) }
func (*SimpleMapReferenceSet) ProtoMessage()    {}
func (*SimpleMapReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{7}
}
func (m *SimpleMapReferenceSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SimpleMapReferenceSet.Unmarshal(m, b)
}
func (m *SimpleMapReferenceSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SimpleMapReferenceSet.Marshal(b, m, deterministic)
}
func (dst *SimpleMapReferenceSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleMapReferenceSet.Merge(dst, src)
}
func (m *SimpleMapReferenceSet) XXX_Size() int {
	return xxx_messageInfo_SimpleMapReferenceSet.Size(m)
}
func (m *SimpleMapReferenceSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleMapReferenceSet.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleMapReferenceSet proto.InternalMessageInfo

func (m *SimpleMapReferenceSet) GetMapTarget() string {
	if m != nil {
		return m.MapTarget
	}
	return ""
}

// ComplexMapReferenceSet represents a complex one-to-many map between SNOMED-CT and another
// coding system.
// A 447250001 |Complex map type reference set|enables representation of maps where each SNOMED
// CT concept may map to one or more codes in a target scheme.
// The type of reference set supports the general set of mapping data required to enable a
// target code to be selected at run-time from a number of alternate codes. It supports
// target code selection by accommodating the inclusion of machine readable rules and/or human readable advice.
// An 609331003 |Extended map type reference set|adds an additional field to allow categorization of maps.
type ComplexMapReferenceSet struct {
	MapGroup             int64    `protobuf:"varint,1,opt,name=map_group,json=mapGroup,proto3" json:"map_group,omitempty"`
	MapPriority          int64    `protobuf:"varint,2,opt,name=map_priority,json=mapPriority,proto3" json:"map_priority,omitempty"`
	MapRule              string   `protobuf:"bytes,3,opt,name=map_rule,json=mapRule,proto3" json:"map_rule,omitempty"`
	MapAdvice            string   `protobuf:"bytes,4,opt,name=map_advice,json=mapAdvice,proto3" json:"map_advice,omitempty"`
	MapTarget            string   `protobuf:"bytes,5,opt,name=map_target,json=mapTarget,proto3" json:"map_target,omitempty"`
	Correlation          int64    `protobuf:"varint,6,opt,name=correlation,proto3" json:"correlation,omitempty"`
	MapCategory          int64    `protobuf:"varint,7,opt,name=map_category,json=mapCategory,proto3" json:"map_category,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplexMapReferenceSet) Reset()         { *m = ComplexMapReferenceSet{} }
func (m *ComplexMapReferenceSet) String() string { return proto.CompactTextString(m) }
func (*ComplexMapReferenceSet) ProtoMessage()    {}
func (*ComplexMapReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{8}
}
func (m *ComplexMapReferenceSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ComplexMapReferenceSet.Unmarshal(m, b)
}
func (m *ComplexMapReferenceSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ComplexMapReferenceSet.Marshal(b, m, deterministic)
}
func (dst *ComplexMapReferenceSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplexMapReferenceSet.Merge(dst, src)
}
func (m *ComplexMapReferenceSet) XXX_Size() int {
	return xxx_messageInfo_ComplexMapReferenceSet.Size(m)
}
func (m *ComplexMapReferenceSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplexMapReferenceSet.DiscardUnknown(m)
}

var xxx_messageInfo_ComplexMapReferenceSet proto.InternalMessageInfo

func (m *ComplexMapReferenceSet) GetMapGroup() int64 {
	if m != nil {
		return m.MapGroup
	}
	return 0
}

func (m *ComplexMapReferenceSet) GetMapPriority() int64 {
	if m != nil {
		return m.MapPriority
	}
	return 0
}

func (m *ComplexMapReferenceSet) GetMapRule() string {
	if m != nil {
		return m.MapRule
	}
	return ""
}

func (m *ComplexMapReferenceSet) GetMapAdvice() string {
	if m != nil {
		return m.MapAdvice
	}
	return ""
}

func (m *ComplexMapReferenceSet) GetMapTarget() string {
	if m != nil {
		return m.MapTarget
	}
	return ""
}

func (m *ComplexMapReferenceSet) GetCorrelation() int64 {
	if m != nil {
		return m.Correlation
	}
	return 0
}

func (m *ComplexMapReferenceSet) GetMapCategory() int64 {
	if m != nil {
		return m.MapCategory
	}
	return 0
}

// ExtendedConcept represents a concept together with
// sufficient additional contextual information relating to the
// concept, including reference set membership as well as
// the underlying concept, the concept's relationships and
// the concept's membership of reference sets, and ways that
// this concept can be refined.
// It is, in essence, a denormalised entity, useful for
// wire-exchange purposes and caching.
type ExtendedConcept struct {
	Concept              *Concept        `protobuf:"bytes,1,opt,name=concept,proto3" json:"concept,omitempty"`
	Relationships        []*Relationship `protobuf:"bytes,2,rep,name=relationships,proto3" json:"relationships,omitempty"`
	PreferredDescription *Description    `protobuf:"bytes,3,opt,name=preferred_description,json=preferredDescription,proto3" json:"preferred_description,omitempty"`
	RecursiveParentIds   []int64         `protobuf:"varint,4,rep,packed,name=recursive_parent_ids,json=recursiveParentIds,proto3" json:"recursive_parent_ids,omitempty"`
	DirectParentIds      []int64         `protobuf:"varint,5,rep,packed,name=direct_parent_ids,json=directParentIds,proto3" json:"direct_parent_ids,omitempty"`
	ConceptRefsets       []int64         `protobuf:"varint,6,rep,packed,name=concept_refsets,json=conceptRefsets,proto3" json:"concept_refsets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ExtendedConcept) Reset()         { *m = ExtendedConcept{} }
func (m *ExtendedConcept) String() string { return proto.CompactTextString(m) }
func (*ExtendedConcept) ProtoMessage()    {}
func (*ExtendedConcept) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{9}
}
func (m *ExtendedConcept) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExtendedConcept.Unmarshal(m, b)
}
func (m *ExtendedConcept) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExtendedConcept.Marshal(b, m, deterministic)
}
func (dst *ExtendedConcept) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendedConcept.Merge(dst, src)
}
func (m *ExtendedConcept) XXX_Size() int {
	return xxx_messageInfo_ExtendedConcept.Size(m)
}
func (m *ExtendedConcept) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendedConcept.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendedConcept proto.InternalMessageInfo

func (m *ExtendedConcept) GetConcept() *Concept {
	if m != nil {
		return m.Concept
	}
	return nil
}

func (m *ExtendedConcept) GetRelationships() []*Relationship {
	if m != nil {
		return m.Relationships
	}
	return nil
}

func (m *ExtendedConcept) GetPreferredDescription() *Description {
	if m != nil {
		return m.PreferredDescription
	}
	return nil
}

func (m *ExtendedConcept) GetRecursiveParentIds() []int64 {
	if m != nil {
		return m.RecursiveParentIds
	}
	return nil
}

func (m *ExtendedConcept) GetDirectParentIds() []int64 {
	if m != nil {
		return m.DirectParentIds
	}
	return nil
}

func (m *ExtendedConcept) GetConceptRefsets() []int64 {
	if m != nil {
		return m.ConceptRefsets
	}
	return nil
}

// ExtendedDescription represents a description together with
// sufficient additional contextual information relating to the
// description, including reference set membership as well as
// the underlying concept, the concept's relationships and
// the concept's membership of reference sets.
// It is, in essence, a denormalised relationship, useful for
// wire-exchange purposes.
// TODO: add language field
type ExtendedDescription struct {
	Description          *Description `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Concept              *Concept     `protobuf:"bytes,3,opt,name=concept,proto3" json:"concept,omitempty"`
	PreferredDescription *Description `protobuf:"bytes,4,opt,name=preferred_description,json=preferredDescription,proto3" json:"preferred_description,omitempty"`
	RecursiveParentIds   []int64      `protobuf:"varint,5,rep,packed,name=recursive_parent_ids,json=recursiveParentIds,proto3" json:"recursive_parent_ids,omitempty"`
	DirectParentIds      []int64      `protobuf:"varint,6,rep,packed,name=direct_parent_ids,json=directParentIds,proto3" json:"direct_parent_ids,omitempty"`
	ConceptRefsets       []int64      `protobuf:"varint,7,rep,packed,name=concept_refsets,json=conceptRefsets,proto3" json:"concept_refsets,omitempty"`
	DescriptionRefsets   []int64      `protobuf:"varint,8,rep,packed,name=description_refsets,json=descriptionRefsets,proto3" json:"description_refsets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ExtendedDescription) Reset()         { *m = ExtendedDescription{} }
func (m *ExtendedDescription) String() string { return proto.CompactTextString(m) }
func (*ExtendedDescription) ProtoMessage()    {}
func (*ExtendedDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{10}
}
func (m *ExtendedDescription) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExtendedDescription.Unmarshal(m, b)
}
func (m *ExtendedDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExtendedDescription.Marshal(b, m, deterministic)
}
func (dst *ExtendedDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendedDescription.Merge(dst, src)
}
func (m *ExtendedDescription) XXX_Size() int {
	return xxx_messageInfo_ExtendedDescription.Size(m)
}
func (m *ExtendedDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendedDescription.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendedDescription proto.InternalMessageInfo

func (m *ExtendedDescription) GetDescription() *Description {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *ExtendedDescription) GetConcept() *Concept {
	if m != nil {
		return m.Concept
	}
	return nil
}

func (m *ExtendedDescription) GetPreferredDescription() *Description {
	if m != nil {
		return m.PreferredDescription
	}
	return nil
}

func (m *ExtendedDescription) GetRecursiveParentIds() []int64 {
	if m != nil {
		return m.RecursiveParentIds
	}
	return nil
}

func (m *ExtendedDescription) GetDirectParentIds() []int64 {
	if m != nil {
		return m.DirectParentIds
	}
	return nil
}

func (m *ExtendedDescription) GetConceptRefsets() []int64 {
	if m != nil {
		return m.ConceptRefsets
	}
	return nil
}

func (m *ExtendedDescription) GetDescriptionRefsets() []int64 {
	if m != nil {
		return m.DescriptionRefsets
	}
	return nil
}

// ConceptReference is a simple reference to a concept with an optional preferred description included.
type ConceptReference struct {
	ConceptId            int64    `protobuf:"varint,1,opt,name=concept_id,json=conceptId,proto3" json:"concept_id,omitempty"`
	Term                 string   `protobuf:"bytes,2,opt,name=term,proto3" json:"term,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConceptReference) Reset()         { *m = ConceptReference{} }
func (m *ConceptReference) String() string { return proto.CompactTextString(m) }
func (*ConceptReference) ProtoMessage()    {}
func (*ConceptReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{11}
}
func (m *ConceptReference) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConceptReference.Unmarshal(m, b)
}
func (m *ConceptReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConceptReference.Marshal(b, m, deterministic)
}
func (dst *ConceptReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConceptReference.Merge(dst, src)
}
func (m *ConceptReference) XXX_Size() int {
	return xxx_messageInfo_ConceptReference.Size(m)
}
func (m *ConceptReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ConceptReference.DiscardUnknown(m)
}

var xxx_messageInfo_ConceptReference proto.InternalMessageInfo

func (m *ConceptReference) GetConceptId() int64 {
	if m != nil {
		return m.ConceptId
	}
	return 0
}

func (m *ConceptReference) GetTerm() string {
	if m != nil {
		return m.Term
	}
	return ""
}

// Expression represents a compound SNOMED CT expression.
// There would usually only be a single concept and possibly some refinement
// See https://confluence.ihtsdotools.org/display/DOCSCG/Compositional+Grammar+-+Specification+and+Guide
// The ABNF grammar for SNOMED compositional grammar (CG) is available here:
// https://github.com/IHTSDO/SNOMEDCT-Languages/blob/master/SnomedCTCompositionalGrammar/CG%20Syntax/Compositional%20Grammar%20v2%20-%20ABNF%20(Normative).txt
type Expression struct {
	DefinitionStatus     Expression_DefinitionStatus `protobuf:"varint,1,opt,name=definition_status,json=definitionStatus,proto3,enum=snomed.Expression_DefinitionStatus" json:"definition_status,omitempty"`
	Clause               *Expression_Clause          `protobuf:"bytes,2,opt,name=clause,proto3" json:"clause,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Expression) Reset()         { *m = Expression{} }
func (m *Expression) String() string { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()    {}
func (*Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{12}
}
func (m *Expression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Expression.Unmarshal(m, b)
}
func (m *Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Expression.Marshal(b, m, deterministic)
}
func (dst *Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression.Merge(dst, src)
}
func (m *Expression) XXX_Size() int {
	return xxx_messageInfo_Expression.Size(m)
}
func (m *Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_Expression proto.InternalMessageInfo

func (m *Expression) GetDefinitionStatus() Expression_DefinitionStatus {
	if m != nil {
		return m.DefinitionStatus
	}
	return Expression_EQUIVALENT_TO
}

func (m *Expression) GetClause() *Expression_Clause {
	if m != nil {
		return m.Clause
	}
	return nil
}

// A clause is a "subexpression" in the CG grammar, with refinements either flat
// or nested in groups
type Expression_Clause struct {
	FocusConcepts        []*ConceptReference           `protobuf:"bytes,1,rep,name=focus_concepts,json=focusConcepts,proto3" json:"focus_concepts,omitempty"`
	Refinements          []*Expression_Refinement      `protobuf:"bytes,2,rep,name=refinements,proto3" json:"refinements,omitempty"`
	RefinementGroups     []*Expression_RefinementGroup `protobuf:"bytes,3,rep,name=refinement_groups,json=refinementGroups,proto3" json:"refinement_groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Expression_Clause) Reset()         { *m = Expression_Clause{} }
func (m *Expression_Clause) String() string { return proto.CompactTextString(m) }
func (*Expression_Clause) ProtoMessage()    {}
func (*Expression_Clause) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{12, 0}
}
func (m *Expression_Clause) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Expression_Clause.Unmarshal(m, b)
}
func (m *Expression_Clause) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Expression_Clause.Marshal(b, m, deterministic)
}
func (dst *Expression_Clause) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression_Clause.Merge(dst, src)
}
func (m *Expression_Clause) XXX_Size() int {
	return xxx_messageInfo_Expression_Clause.Size(m)
}
func (m *Expression_Clause) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression_Clause.DiscardUnknown(m)
}

var xxx_messageInfo_Expression_Clause proto.InternalMessageInfo

func (m *Expression_Clause) GetFocusConcepts() []*ConceptReference {
	if m != nil {
		return m.FocusConcepts
	}
	return nil
}

func (m *Expression_Clause) GetRefinements() []*Expression_Refinement {
	if m != nil {
		return m.Refinements
	}
	return nil
}

func (m *Expression_Clause) GetRefinementGroups() []*Expression_RefinementGroup {
	if m != nil {
		return m.RefinementGroups
	}
	return nil
}

type Expression_RefinementGroup struct {
	Refinements          []*Expression_Refinement `protobuf:"bytes,1,rep,name=refinements,proto3" json:"refinements,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Expression_RefinementGroup) Reset()         { *m = Expression_RefinementGroup{} }
func (m *Expression_RefinementGroup) String() string { return proto.CompactTextString(m) }
func (*Expression_RefinementGroup) ProtoMessage()    {}
func (*Expression_RefinementGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{12, 1}
}
func (m *Expression_RefinementGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Expression_RefinementGroup.Unmarshal(m, b)
}
func (m *Expression_RefinementGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Expression_RefinementGroup.Marshal(b, m, deterministic)
}
func (dst *Expression_RefinementGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression_RefinementGroup.Merge(dst, src)
}
func (m *Expression_RefinementGroup) XXX_Size() int {
	return xxx_messageInfo_Expression_RefinementGroup.Size(m)
}
func (m *Expression_RefinementGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression_RefinementGroup.DiscardUnknown(m)
}

var xxx_messageInfo_Expression_RefinementGroup proto.InternalMessageInfo

func (m *Expression_RefinementGroup) GetRefinements() []*Expression_Refinement {
	if m != nil {
		return m.Refinements
	}
	return nil
}

// Refinement is a name/value pair (an attribute) permitting refinement of the focus concept(s)
// The value can be a concept, a clause, or a concrete value such as a string, integer or double
type Expression_Refinement struct {
	RefinementConcept *ConceptReference `protobuf:"bytes,1,opt,name=refinement_concept,json=refinementConcept,proto3" json:"refinement_concept,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Expression_Refinement_ConceptValue
	//	*Expression_Refinement_ClauseValue
	//	*Expression_Refinement_StringValue
	//	*Expression_Refinement_IntValue
	//	*Expression_Refinement_DoubleValue
	Value                isExpression_Refinement_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Expression_Refinement) Reset()         { *m = Expression_Refinement{} }
func (m *Expression_Refinement) String() string { return proto.CompactTextString(m) }
func (*Expression_Refinement) ProtoMessage()    {}
func (*Expression_Refinement) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{12, 2}
}
func (m *Expression_Refinement) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Expression_Refinement.Unmarshal(m, b)
}
func (m *Expression_Refinement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Expression_Refinement.Marshal(b, m, deterministic)
}
func (dst *Expression_Refinement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression_Refinement.Merge(dst, src)
}
func (m *Expression_Refinement) XXX_Size() int {
	return xxx_messageInfo_Expression_Refinement.Size(m)
}
func (m *Expression_Refinement) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression_Refinement.DiscardUnknown(m)
}

var xxx_messageInfo_Expression_Refinement proto.InternalMessageInfo

type isExpression_Refinement_Value interface {
	isExpression_Refinement_Value()
}

type Expression_Refinement_ConceptValue struct {
	ConceptValue *ConceptReference `protobuf:"bytes,2,opt,name=concept_value,json=conceptValue,proto3,oneof"`
}
type Expression_Refinement_ClauseValue struct {
	ClauseValue *Expression_Clause `protobuf:"bytes,3,opt,name=clause_value,json=clauseValue,proto3,oneof"`
}
type Expression_Refinement_StringValue struct {
	StringValue string `protobuf:"bytes,4,opt,name=string_value,json=stringValue,proto3,oneof"`
}
type Expression_Refinement_IntValue struct {
	IntValue int64 `protobuf:"varint,5,opt,name=int_value,json=intValue,proto3,oneof"`
}
type Expression_Refinement_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,6,opt,name=double_value,json=doubleValue,proto3,oneof"`
}

func (*Expression_Refinement_ConceptValue) isExpression_Refinement_Value() {}
func (*Expression_Refinement_ClauseValue) isExpression_Refinement_Value()  {}
func (*Expression_Refinement_StringValue) isExpression_Refinement_Value()  {}
func (*Expression_Refinement_IntValue) isExpression_Refinement_Value()     {}
func (*Expression_Refinement_DoubleValue) isExpression_Refinement_Value()  {}

func (m *Expression_Refinement) GetValue() isExpression_Refinement_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Expression_Refinement) GetRefinementConcept() *ConceptReference {
	if m != nil {
		return m.RefinementConcept
	}
	return nil
}

func (m *Expression_Refinement) GetConceptValue() *ConceptReference {
	if x, ok := m.GetValue().(*Expression_Refinement_ConceptValue); ok {
		return x.ConceptValue
	}
	return nil
}

func (m *Expression_Refinement) GetClauseValue() *Expression_Clause {
	if x, ok := m.GetValue().(*Expression_Refinement_ClauseValue); ok {
		return x.ClauseValue
	}
	return nil
}

func (m *Expression_Refinement) GetStringValue() string {
	if x, ok := m.GetValue().(*Expression_Refinement_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Expression_Refinement) GetIntValue() int64 {
	if x, ok := m.GetValue().(*Expression_Refinement_IntValue); ok {
		return x.IntValue
	}
	return 0
}

func (m *Expression_Refinement) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*Expression_Refinement_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Expression_Refinement) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Expression_Refinement_OneofMarshaler, _Expression_Refinement_OneofUnmarshaler, _Expression_Refinement_OneofSizer, []interface{}{
		(*Expression_Refinement_ConceptValue)(nil),
		(*Expression_Refinement_ClauseValue)(nil),
		(*Expression_Refinement_StringValue)(nil),
		(*Expression_Refinement_IntValue)(nil),
		(*Expression_Refinement_DoubleValue)(nil),
	}
}

func _Expression_Refinement_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Expression_Refinement)
	// value
	switch x := m.Value.(type) {
	case *Expression_Refinement_ConceptValue:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConceptValue); err != nil {
			return err
		}
	case *Expression_Refinement_ClauseValue:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClauseValue); err != nil {
			return err
		}
	case *Expression_Refinement_StringValue:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StringValue)
	case *Expression_Refinement_IntValue:
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IntValue))
	case *Expression_Refinement_DoubleValue:
		b.EncodeVarint(6<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.DoubleValue))
	case nil:
	default:
		return fmt.Errorf("Expression_Refinement.Value has unexpected type %T", x)
	}
	return nil
}

func _Expression_Refinement_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Expression_Refinement)
	switch tag {
	case 2: // value.concept_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConceptReference)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_Refinement_ConceptValue{msg}
		return true, err
	case 3: // value.clause_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Expression_Clause)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_Refinement_ClauseValue{msg}
		return true, err
	case 4: // value.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Expression_Refinement_StringValue{x}
		return true, err
	case 5: // value.int_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Expression_Refinement_IntValue{int64(x)}
		return true, err
	case 6: // value.double_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Expression_Refinement_DoubleValue{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Expression_Refinement_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Expression_Refinement)
	// value
	switch x := m.Value.(type) {
	case *Expression_Refinement_ConceptValue:
		s := proto.Size(x.ConceptValue)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Refinement_ClauseValue:
		s := proto.Size(x.ClauseValue)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Refinement_StringValue:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.StringValue)))
		n += len(x.StringValue)
	case *Expression_Refinement_IntValue:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.IntValue))
	case *Expression_Refinement_DoubleValue:
		n += 1 // tag and wire
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SubsumptionRequest requests a test of subsumption
// This is based on on the HL7 FHIR terminology service definition
// Does concept A subsumes concept B?
// e.g. A:Disorder of liver, B: viral hepatitis. Result: Subsumes
// See https://www.hl7.org/fhir/terminology-service.html
type SubsumptionRequest struct {
	System               string   `protobuf:"bytes,1,opt,name=system,proto3" json:"system,omitempty"`
	CodeA                int64    `protobuf:"varint,2,opt,name=code_a,json=codeA,proto3" json:"code_a,omitempty"`
	CodeB                int64    `protobuf:"varint,3,opt,name=code_b,json=codeB,proto3" json:"code_b,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubsumptionRequest) Reset()         { *m = SubsumptionRequest{} }
func (m *SubsumptionRequest) String() string { return proto.CompactTextString(m) }
func (*SubsumptionRequest) ProtoMessage()    {}
func (*SubsumptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{13}
}
func (m *SubsumptionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubsumptionRequest.Unmarshal(m, b)
}
func (m *SubsumptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubsumptionRequest.Marshal(b, m, deterministic)
}
func (dst *SubsumptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubsumptionRequest.Merge(dst, src)
}
func (m *SubsumptionRequest) XXX_Size() int {
	return xxx_messageInfo_SubsumptionRequest.Size(m)
}
func (m *SubsumptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubsumptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubsumptionRequest proto.InternalMessageInfo

func (m *SubsumptionRequest) GetSystem() string {
	if m != nil {
		return m.System
	}
	return ""
}

func (m *SubsumptionRequest) GetCodeA() int64 {
	if m != nil {
		return m.CodeA
	}
	return 0
}

func (m *SubsumptionRequest) GetCodeB() int64 {
	if m != nil {
		return m.CodeB
	}
	return 0
}

// SubsumptionResponse gives the response of subsumption testing
type SubsumptionResponse struct {
	Result               SubsumptionResponse_Result `protobuf:"varint,1,opt,name=result,proto3,enum=snomed.SubsumptionResponse_Result" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SubsumptionResponse) Reset()         { *m = SubsumptionResponse{} }
func (m *SubsumptionResponse) String() string { return proto.CompactTextString(m) }
func (*SubsumptionResponse) ProtoMessage()    {}
func (*SubsumptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{14}
}
func (m *SubsumptionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubsumptionResponse.Unmarshal(m, b)
}
func (m *SubsumptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubsumptionResponse.Marshal(b, m, deterministic)
}
func (dst *SubsumptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubsumptionResponse.Merge(dst, src)
}
func (m *SubsumptionResponse) XXX_Size() int {
	return xxx_messageInfo_SubsumptionResponse.Size(m)
}
func (m *SubsumptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubsumptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubsumptionResponse proto.InternalMessageInfo

func (m *SubsumptionResponse) GetResult() SubsumptionResponse_Result {
	if m != nil {
		return m.Result
	}
	return SubsumptionResponse_EQUIVALENT
}

type TranslateRequest struct {
	ConceptId            int64    `protobuf:"varint,1,opt,name=concept_id,json=conceptId,proto3" json:"concept_id,omitempty"`
	TargetId             int64    `protobuf:"varint,2,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TranslateRequest) Reset()         { *m = TranslateRequest{} }
func (m *TranslateRequest) String() string { return proto.CompactTextString(m) }
func (*TranslateRequest) ProtoMessage()    {}
func (*TranslateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{15}
}
func (m *TranslateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranslateRequest.Unmarshal(m, b)
}
func (m *TranslateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranslateRequest.Marshal(b, m, deterministic)
}
func (dst *TranslateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranslateRequest.Merge(dst, src)
}
func (m *TranslateRequest) XXX_Size() int {
	return xxx_messageInfo_TranslateRequest.Size(m)
}
func (m *TranslateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TranslateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TranslateRequest proto.InternalMessageInfo

func (m *TranslateRequest) GetConceptId() int64 {
	if m != nil {
		return m.ConceptId
	}
	return 0
}

func (m *TranslateRequest) GetTargetId() int64 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

type TranslateResponse struct {
	// Types that are valid to be assigned to Result:
	//	*TranslateResponse_Concept
	//	*TranslateResponse_Mapped
	Result               isTranslateResponse_Result `protobuf_oneof:"result"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TranslateResponse) Reset()         { *m = TranslateResponse{} }
func (m *TranslateResponse) String() string { return proto.CompactTextString(m) }
func (*TranslateResponse) ProtoMessage()    {}
func (*TranslateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{16}
}
func (m *TranslateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranslateResponse.Unmarshal(m, b)
}
func (m *TranslateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranslateResponse.Marshal(b, m, deterministic)
}
func (dst *TranslateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranslateResponse.Merge(dst, src)
}
func (m *TranslateResponse) XXX_Size() int {
	return xxx_messageInfo_TranslateResponse.Size(m)
}
func (m *TranslateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TranslateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TranslateResponse proto.InternalMessageInfo

type isTranslateResponse_Result interface {
	isTranslateResponse_Result()
}

type TranslateResponse_Concept struct {
	Concept *Concept `protobuf:"bytes,1,opt,name=concept,proto3,oneof"`
}
type TranslateResponse_Mapped struct {
	Mapped *TranslateResponse_MappedResponse `protobuf:"bytes,2,opt,name=mapped,proto3,oneof"`
}

func (*TranslateResponse_Concept) isTranslateResponse_Result() {}
func (*TranslateResponse_Mapped) isTranslateResponse_Result()  {}

func (m *TranslateResponse) GetResult() isTranslateResponse_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *TranslateResponse) GetConcept() *Concept {
	if x, ok := m.GetResult().(*TranslateResponse_Concept); ok {
		return x.Concept
	}
	return nil
}

func (m *TranslateResponse) GetMapped() *TranslateResponse_MappedResponse {
	if x, ok := m.GetResult().(*TranslateResponse_Mapped); ok {
		return x.Mapped
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TranslateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TranslateResponse_OneofMarshaler, _TranslateResponse_OneofUnmarshaler, _TranslateResponse_OneofSizer, []interface{}{
		(*TranslateResponse_Concept)(nil),
		(*TranslateResponse_Mapped)(nil),
	}
}

func _TranslateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TranslateResponse)
	// result
	switch x := m.Result.(type) {
	case *TranslateResponse_Concept:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Concept); err != nil {
			return err
		}
	case *TranslateResponse_Mapped:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mapped); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TranslateResponse.Result has unexpected type %T", x)
	}
	return nil
}

func _TranslateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TranslateResponse)
	switch tag {
	case 1: // result.concept
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Concept)
		err := b.DecodeMessage(msg)
		m.Result = &TranslateResponse_Concept{msg}
		return true, err
	case 2: // result.mapped
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TranslateResponse_MappedResponse)
		err := b.DecodeMessage(msg)
		m.Result = &TranslateResponse_Mapped{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TranslateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TranslateResponse)
	// result
	switch x := m.Result.(type) {
	case *TranslateResponse_Concept:
		s := proto.Size(x.Concept)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TranslateResponse_Mapped:
		s := proto.Size(x.Mapped)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TranslateResponse_MappedResponse struct {
	Items                []*ReferenceSetItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TranslateResponse_MappedResponse) Reset()         { *m = TranslateResponse_MappedResponse{} }
func (m *TranslateResponse_MappedResponse) String() string { return proto.CompactTextString(m) }
func (*TranslateResponse_MappedResponse) ProtoMessage()    {}
func (*TranslateResponse_MappedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{16, 0}
}
func (m *TranslateResponse_MappedResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranslateResponse_MappedResponse.Unmarshal(m, b)
}
func (m *TranslateResponse_MappedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranslateResponse_MappedResponse.Marshal(b, m, deterministic)
}
func (dst *TranslateResponse_MappedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranslateResponse_MappedResponse.Merge(dst, src)
}
func (m *TranslateResponse_MappedResponse) XXX_Size() int {
	return xxx_messageInfo_TranslateResponse_MappedResponse.Size(m)
}
func (m *TranslateResponse_MappedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TranslateResponse_MappedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TranslateResponse_MappedResponse proto.InternalMessageInfo

func (m *TranslateResponse_MappedResponse) GetItems() []*ReferenceSetItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ParseRequest struct {
	S                    string   `protobuf:"bytes,1,opt,name=s,proto3" json:"s,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParseRequest) Reset()         { *m = ParseRequest{} }
func (m *ParseRequest) String() string { return proto.CompactTextString(m) }
func (*ParseRequest) ProtoMessage()    {}
func (*ParseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{17}
}
func (m *ParseRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ParseRequest.Unmarshal(m, b)
}
func (m *ParseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ParseRequest.Marshal(b, m, deterministic)
}
func (dst *ParseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParseRequest.Merge(dst, src)
}
func (m *ParseRequest) XXX_Size() int {
	return xxx_messageInfo_ParseRequest.Size(m)
}
func (m *ParseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ParseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ParseRequest proto.InternalMessageInfo

func (m *ParseRequest) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

// SearchRequest permits an arbitrary free-text search of the hierarchy.
type SearchRequest struct {
	Search               string              `protobuf:"bytes,1,opt,name=search,proto3" json:"search,omitempty"`
	RecursiveParentIds   []int64             `protobuf:"varint,2,rep,packed,name=recursive_parent_ids,json=recursiveParentIds,proto3" json:"recursive_parent_ids,omitempty"`
	DirectParentIds      []int64             `protobuf:"varint,3,rep,packed,name=direct_parent_ids,json=directParentIds,proto3" json:"direct_parent_ids,omitempty"`
	ReferenceSetIds      []int64             `protobuf:"varint,4,rep,packed,name=reference_set_ids,json=referenceSetIds,proto3" json:"reference_set_ids,omitempty"`
	MaximumHits          int32               `protobuf:"varint,5,opt,name=maximum_hits,json=maximumHits,proto3" json:"maximum_hits,omitempty"`
	IncludeInactive      bool                `protobuf:"varint,6,opt,name=include_inactive,json=includeInactive,proto3" json:"include_inactive,omitempty"`
	Fuzzy                SearchRequest_Fuzzy `protobuf:"varint,7,opt,name=fuzzy,proto3,enum=snomed.SearchRequest_Fuzzy" json:"fuzzy,omitempty"`
	AcceptedLanguages    string              `protobuf:"bytes,8,opt,name=accepted_languages,json=acceptedLanguages,proto3" json:"accepted_languages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SearchRequest) Reset()         { *m = SearchRequest{} }
func (m *SearchRequest) String() string { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()    {}
func (*SearchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{18}
}
func (m *SearchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchRequest.Unmarshal(m, b)
}
func (m *SearchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchRequest.Marshal(b, m, deterministic)
}
func (dst *SearchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchRequest.Merge(dst, src)
}
func (m *SearchRequest) XXX_Size() int {
	return xxx_messageInfo_SearchRequest.Size(m)
}
func (m *SearchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchRequest proto.InternalMessageInfo

func (m *SearchRequest) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

func (m *SearchRequest) GetRecursiveParentIds() []int64 {
	if m != nil {
		return m.RecursiveParentIds
	}
	return nil
}

func (m *SearchRequest) GetDirectParentIds() []int64 {
	if m != nil {
		return m.DirectParentIds
	}
	return nil
}

func (m *SearchRequest) GetReferenceSetIds() []int64 {
	if m != nil {
		return m.ReferenceSetIds
	}
	return nil
}

func (m *SearchRequest) GetMaximumHits() int32 {
	if m != nil {
		return m.MaximumHits
	}
	return 0
}

func (m *SearchRequest) GetIncludeInactive() bool {
	if m != nil {
		return m.IncludeInactive
	}
	return false
}

func (m *SearchRequest) GetFuzzy() SearchRequest_Fuzzy {
	if m != nil {
		return m.Fuzzy
	}
	return SearchRequest_FALLBACK_FUZZY
}

func (m *SearchRequest) GetAcceptedLanguages() string {
	if m != nil {
		return m.AcceptedLanguages
	}
	return ""
}

// SearchResponse provides an optimised search response, sufficient for display purposes.
type SearchResponse struct {
	Items                []*SearchResponse_Item `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SearchResponse) Reset()         { *m = SearchResponse{} }
func (m *SearchResponse) String() string { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()    {}
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{19}
}
func (m *SearchResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchResponse.Unmarshal(m, b)
}
func (m *SearchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchResponse.Marshal(b, m, deterministic)
}
func (dst *SearchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse.Merge(dst, src)
}
func (m *SearchResponse) XXX_Size() int {
	return xxx_messageInfo_SearchResponse.Size(m)
}
func (m *SearchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse proto.InternalMessageInfo

func (m *SearchResponse) GetItems() []*SearchResponse_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type SearchResponse_Item struct {
	Term                 string   `protobuf:"bytes,1,opt,name=term,proto3" json:"term,omitempty"`
	ConceptId            int64    `protobuf:"varint,2,opt,name=concept_id,json=conceptId,proto3" json:"concept_id,omitempty"`
	PreferredTerm        string   `protobuf:"bytes,3,opt,name=preferred_term,json=preferredTerm,proto3" json:"preferred_term,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchResponse_Item) Reset()         { *m = SearchResponse_Item{} }
func (m *SearchResponse_Item) String() string { return proto.CompactTextString(m) }
func (*SearchResponse_Item) ProtoMessage()    {}
func (*SearchResponse_Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_snomed_07ea31b0e4b3d000, []int{19, 0}
}
func (m *SearchResponse_Item) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchResponse_Item.Unmarshal(m, b)
}
func (m *SearchResponse_Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchResponse_Item.Marshal(b, m, deterministic)
}
func (dst *SearchResponse_Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse_Item.Merge(dst, src)
}
func (m *SearchResponse_Item) XXX_Size() int {
	return xxx_messageInfo_SearchResponse_Item.Size(m)
}
func (m *SearchResponse_Item) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse_Item.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse_Item proto.InternalMessageInfo

func (m *SearchResponse_Item) GetTerm() string {
	if m != nil {
		return m.Term
	}
	return ""
}

func (m *SearchResponse_Item) GetConceptId() int64 {
	if m != nil {
		return m.ConceptId
	}
	return 0
}

func (m *SearchResponse_Item) GetPreferredTerm() string {
	if m != nil {
		return m.PreferredTerm
	}
	return ""
}

func init() {
	proto.RegisterType((*Concept)(nil), "snomed.Concept")
	proto.RegisterType((*Description)(nil), "snomed.Description")
	proto.RegisterType((*Relationship)(nil), "snomed.Relationship")
	proto.RegisterType((*ReferenceSetItem)(nil), "snomed.ReferenceSetItem")
	proto.RegisterType((*RefSetDescriptorReferenceSet)(nil), "snomed.RefSetDescriptorReferenceSet")
	proto.RegisterType((*SimpleReferenceSet)(nil), "snomed.SimpleReferenceSet")
	proto.RegisterType((*LanguageReferenceSet)(nil), "snomed.LanguageReferenceSet")
	proto.RegisterType((*SimpleMapReferenceSet)(nil), "snomed.SimpleMapReferenceSet")
	proto.RegisterType((*ComplexMapReferenceSet)(nil), "snomed.ComplexMapReferenceSet")
	proto.RegisterType((*ExtendedConcept)(nil), "snomed.ExtendedConcept")
	proto.RegisterType((*ExtendedDescription)(nil), "snomed.ExtendedDescription")
	proto.RegisterType((*ConceptReference)(nil), "snomed.ConceptReference")
	proto.RegisterType((*Expression)(nil), "snomed.Expression")
	proto.RegisterType((*Expression_Clause)(nil), "snomed.Expression.Clause")
	proto.RegisterType((*Expression_RefinementGroup)(nil), "snomed.Expression.RefinementGroup")
	proto.RegisterType((*Expression_Refinement)(nil), "snomed.Expression.Refinement")
	proto.RegisterType((*SubsumptionRequest)(nil), "snomed.SubsumptionRequest")
	proto.RegisterType((*SubsumptionResponse)(nil), "snomed.SubsumptionResponse")
	proto.RegisterType((*TranslateRequest)(nil), "snomed.TranslateRequest")
	proto.RegisterType((*TranslateResponse)(nil), "snomed.TranslateResponse")
	proto.RegisterType((*TranslateResponse_MappedResponse)(nil), "snomed.TranslateResponse.MappedResponse")
	proto.RegisterType((*ParseRequest)(nil), "snomed.ParseRequest")
	proto.RegisterType((*SearchRequest)(nil), "snomed.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "snomed.SearchResponse")
	proto.RegisterType((*SearchResponse_Item)(nil), "snomed.SearchResponse.Item")
	proto.RegisterEnum("snomed.Expression_DefinitionStatus", Expression_DefinitionStatus_name, Expression_DefinitionStatus_value)
	proto.RegisterEnum("snomed.SubsumptionResponse_Result", SubsumptionResponse_Result_name, SubsumptionResponse_Result_value)
	proto.RegisterEnum("snomed.SearchRequest_Fuzzy", SearchRequest_Fuzzy_name, SearchRequest_Fuzzy_value)
}

func init() { proto.RegisterFile("snomed.proto", fileDescriptor_snomed_07ea31b0e4b3d000) }

var fileDescriptor_snomed_07ea31b0e4b3d000 = []byte{
	// 1822 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x5b, 0x6f, 0x1b, 0xc7,
	0xf5, 0xd7, 0x92, 0x22, 0x45, 0x1e, 0x5e, 0x35, 0x96, 0x1d, 0x46, 0xb6, 0xff, 0xd1, 0x7f, 0xdd,
	0x20, 0x4a, 0x82, 0xd2, 0xb6, 0x9a, 0x04, 0x45, 0x0a, 0xc4, 0x25, 0x65, 0x39, 0x62, 0x2b, 0x5b,
	0xea, 0x52, 0x4a, 0x61, 0xbf, 0x6c, 0x57, 0x3b, 0x43, 0x7a, 0x00, 0xee, 0xa5, 0x33, 0xb3, 0x86,
	0x94, 0xcf, 0x52, 0xf4, 0xad, 0x8f, 0x7d, 0xea, 0x27, 0x28, 0x8a, 0x02, 0xed, 0x5b, 0xdf, 0xfb,
	0x3d, 0x0a, 0xf4, 0xa9, 0xc5, 0xdc, 0x76, 0x97, 0x94, 0x14, 0xd7, 0x40, 0x81, 0xe6, 0x4d, 0xf3,
	0x3b, 0xbf, 0x73, 0x74, 0xe6, 0xcc, 0xb9, 0x2d, 0xa1, 0xcd, 0xe3, 0x24, 0x22, 0x78, 0x98, 0xb2,
	0x44, 0x24, 0xa8, 0xae, 0x4f, 0xdb, 0x1f, 0xcc, 0x93, 0x64, 0xbe, 0x20, 0x0f, 0x15, 0x7a, 0x9e,
	0xcd, 0x1e, 0x0a, 0x1a, 0x11, 0x2e, 0x82, 0x28, 0xd5, 0x44, 0xf7, 0x4f, 0x0e, 0x6c, 0xec, 0x27,
	0x71, 0x48, 0x52, 0x81, 0xba, 0x50, 0xa1, 0x78, 0xe0, 0xec, 0x38, 0xbb, 0x55, 0xaf, 0x42, 0x31,
	0x1a, 0x41, 0x97, 0xcc, 0x66, 0x24, 0x14, 0xf4, 0x0d, 0xf1, 0xa5, 0xe2, 0xa0, 0xb2, 0xe3, 0xec,
	0xb6, 0xf6, 0xb6, 0x87, 0xda, 0xea, 0xd0, 0x5a, 0x1d, 0x9e, 0x5a, 0xab, 0x5e, 0x27, 0xd7, 0x90,
	0x18, 0xba, 0x03, 0xf5, 0x40, 0x9d, 0x06, 0xd5, 0x1d, 0x67, 0xb7, 0xe1, 0x99, 0x13, 0xba, 0x0b,
	0xcd, 0x28, 0xc1, 0xd9, 0x82, 0xf8, 0x14, 0x0f, 0xd6, 0xd5, 0x7f, 0x6c, 0x68, 0x60, 0x82, 0xd1,
	0x23, 0xd8, 0xc2, 0x64, 0x46, 0x63, 0x2a, 0x68, 0x12, 0xfb, 0x5c, 0x04, 0x22, 0xe3, 0x92, 0x57,
	0x53, 0x3c, 0x54, 0xc8, 0xa6, 0x4a, 0x34, 0xc1, 0xee, 0x1f, 0x2a, 0xd0, 0x7a, 0x4a, 0x78, 0xc8,
	0x68, 0x2a, 0xf1, 0xef, 0xcd, 0x4d, 0xee, 0x03, 0x84, 0x3a, 0xb8, 0x85, 0xff, 0x4d, 0x83, 0x4c,
	0x30, 0x7a, 0x00, 0x9d, 0x45, 0x10, 0xcf, 0xb3, 0x60, 0x4e, 0xfc, 0x30, 0xc1, 0x64, 0x50, 0xdf,
	0x71, 0x76, 0x9b, 0x5e, 0xdb, 0x82, 0xfb, 0x09, 0x26, 0xe8, 0x3d, 0xd8, 0x10, 0x97, 0xa9, 0x32,
	0xbf, 0xa1, 0x0c, 0xd4, 0xe5, 0x71, 0x82, 0x11, 0x82, 0x75, 0x41, 0x58, 0x34, 0x68, 0x28, 0x25,
	0xf5, 0x37, 0xfa, 0x14, 0x36, 0xc3, 0x80, 0x13, 0x9f, 0xd3, 0x79, 0x4c, 0x67, 0x34, 0x0c, 0xe2,
	0x90, 0x0c, 0x9a, 0x4a, 0xad, 0x2f, 0x05, 0xd3, 0x12, 0xee, 0xfe, 0xb3, 0x02, 0x6d, 0x8f, 0x2c,
	0x02, 0x19, 0x32, 0xfe, 0x9a, 0xa6, 0xdf, 0x9b, 0xb0, 0xdd, 0x85, 0x26, 0x4f, 0x32, 0x16, 0x92,
	0x22, 0x6a, 0x0d, 0x0d, 0x4c, 0x30, 0xfa, 0x10, 0xba, 0x98, 0x70, 0x41, 0x63, 0xe5, 0xb7, 0x64,
	0xd4, 0x15, 0xa3, 0x53, 0x42, 0x27, 0x18, 0xfd, 0x10, 0x10, 0x2b, 0xdd, 0xcd, 0x9f, 0xb3, 0x24,
	0x4b, 0x4d, 0x04, 0x37, 0xcb, 0x92, 0xaf, 0xa5, 0xa0, 0x1c, 0xe5, 0xc6, 0x52, 0x94, 0x3f, 0x83,
	0x3b, 0xe1, 0xeb, 0x80, 0x05, 0xa1, 0x20, 0x8c, 0x72, 0x41, 0x43, 0xdf, 0xf2, 0x74, 0x58, 0xb7,
	0x96, 0xa5, 0xa7, 0x5a, 0xeb, 0x03, 0x68, 0x45, 0x09, 0xa6, 0x33, 0x4a, 0x98, 0xa4, 0x82, 0xa2,
	0x82, 0x85, 0x26, 0xd8, 0xfd, 0xe3, 0x3a, 0xf4, 0x3d, 0x32, 0x23, 0x8c, 0xc4, 0x21, 0x99, 0x12,
	0x31, 0x11, 0x24, 0x2a, 0xc5, 0xbf, 0xf9, 0xbf, 0x8e, 0x3f, 0x23, 0x33, 0x4e, 0x4a, 0x59, 0xdb,
	0xd0, 0xc0, 0x04, 0xa3, 0x2f, 0xe0, 0x3d, 0x66, 0x1d, 0xc7, 0x7e, 0x98, 0x44, 0x69, 0x12, 0x93,
	0x58, 0x14, 0x0f, 0x71, 0xbb, 0x10, 0xef, 0x5b, 0xe9, 0x04, 0xa3, 0x29, 0x6c, 0x1a, 0xa3, 0xd8,
	0x54, 0x6a, 0xc2, 0xd4, 0x7b, 0xb4, 0xf6, 0x7e, 0x30, 0x34, 0xcd, 0xcb, 0x23, 0xb3, 0x29, 0x11,
	0x4f, 0x73, 0x79, 0x39, 0x42, 0x87, 0x6b, 0x5e, 0x5f, 0x1b, 0x28, 0xe4, 0xe8, 0x33, 0xa8, 0x73,
	0x1a, 0xa5, 0x0b, 0xa2, 0x5e, 0x4d, 0x46, 0xc6, 0x58, 0x9a, 0x2a, 0x74, 0x45, 0xdf, 0x70, 0xd1,
	0x97, 0xd0, 0xb0, 0x25, 0xa6, 0x5e, 0xb1, 0xb5, 0x77, 0xcf, 0xea, 0x1d, 0x19, 0x7c, 0x45, 0x33,
	0xe7, 0xa3, 0xaf, 0x00, 0xb4, 0x15, 0x3f, 0x0a, 0x52, 0xf5, 0xb0, 0xad, 0xbd, 0xfb, 0xcb, 0xff,
	0xf5, 0x79, 0x90, 0xae, 0xa8, 0x37, 0xb9, 0x15, 0xa0, 0x11, 0xb4, 0x64, 0xcc, 0x16, 0xe4, 0x42,
	0x19, 0x68, 0x29, 0x03, 0xff, 0x67, 0x0d, 0xec, 0x6b, 0xd1, 0x55, 0x0b, 0x10, 0xe6, 0x92, 0x71,
	0x1d, 0xd6, 0xcf, 0x13, 0x7c, 0xe9, 0xfe, 0xde, 0x81, 0x7b, 0xdf, 0x15, 0x31, 0xf4, 0x63, 0x18,
	0x04, 0x42, 0x30, 0x7a, 0x9e, 0x09, 0x92, 0x47, 0xdd, 0x14, 0x8d, 0xae, 0xf2, 0x3b, 0xb9, 0xbc,
	0xd4, 0x3e, 0x27, 0x18, 0x7d, 0x02, 0x9b, 0x85, 0xa6, 0x4d, 0xf8, 0x8a, 0x52, 0xe9, 0xe5, 0x02,
	0x93, 0xeb, 0x1f, 0x41, 0x01, 0xf9, 0x09, 0xc3, 0x84, 0xa9, 0x5c, 0xeb, 0x78, 0xdd, 0x1c, 0x3e,
	0x96, 0xa8, 0xbb, 0x05, 0xe8, 0xea, 0xb3, 0xb8, 0x23, 0xd8, 0xba, 0x2e, 0xe8, 0xe8, 0x63, 0xe8,
	0x07, 0xa1, 0x6c, 0x94, 0xc1, 0x39, 0x5d, 0x50, 0x71, 0x59, 0x38, 0xdd, 0x5b, 0xc2, 0x27, 0xd8,
	0xfd, 0x02, 0x6e, 0x5f, 0x1b, 0x79, 0xd9, 0x7f, 0xa3, 0x20, 0xf5, 0x45, 0xc0, 0xe6, 0x44, 0x98,
	0xc2, 0x6a, 0x46, 0x41, 0x7a, 0xaa, 0x00, 0xf7, 0x1f, 0x0e, 0xdc, 0xb9, 0x3e, 0xe2, 0xaa, 0x3e,
	0x02, 0xdb, 0x35, 0x1c, 0x53, 0x1f, 0x81, 0x69, 0x16, 0xff, 0x0f, 0x6d, 0x29, 0x4c, 0x19, 0x4d,
	0x18, 0x15, 0x97, 0x26, 0x30, 0xad, 0x28, 0x48, 0x4f, 0x0c, 0x84, 0xde, 0x07, 0x49, 0xf7, 0x59,
	0xb6, 0xd0, 0x95, 0xd7, 0xf4, 0x36, 0xa2, 0x20, 0xf5, 0xb2, 0x05, 0xb1, 0x4e, 0x05, 0xf8, 0x0d,
	0x0d, 0x89, 0xaa, 0x3d, 0xed, 0xd4, 0x48, 0x01, 0x2b, 0x3e, 0xd7, 0x56, 0x7c, 0x46, 0x3b, 0x32,
	0x7f, 0x98, 0x6d, 0x60, 0xa6, 0xe4, 0xca, 0x90, 0xf5, 0x2e, 0x0c, 0x04, 0x99, 0x27, 0xec, 0xd2,
	0xf4, 0x3c, 0xe9, 0xdd, 0xbe, 0x81, 0xdc, 0xbf, 0x56, 0xa0, 0x77, 0x70, 0x21, 0x48, 0x8c, 0x65,
	0x8d, 0xea, 0xe9, 0xff, 0x31, 0x6c, 0x98, 0xc9, 0xa4, 0xee, 0xdb, 0xda, 0xeb, 0x15, 0x49, 0xa9,
	0x60, 0xcf, 0xca, 0xd1, 0x97, 0xd0, 0x29, 0x77, 0x50, 0x3e, 0xa8, 0xec, 0x54, 0x77, 0x5b, 0x7b,
	0x5b, 0x45, 0x19, 0x17, 0x42, 0x6f, 0x99, 0x8a, 0x0e, 0xe1, 0x76, 0xaa, 0x1a, 0x04, 0x23, 0xb8,
	0x9c, 0x93, 0x2a, 0x4a, 0xad, 0xbd, 0x5b, 0xd6, 0x46, 0x29, 0x1f, 0xbd, 0xad, 0x5c, 0xa3, 0x3c,
	0xe4, 0x1f, 0xc1, 0x16, 0x23, 0x61, 0xc6, 0xb8, 0xec, 0x8e, 0x69, 0xc0, 0x74, 0x13, 0xe2, 0x83,
	0xf5, 0x9d, 0xaa, 0x5c, 0x13, 0x72, 0xd9, 0x89, 0x12, 0x4d, 0x30, 0x97, 0x59, 0x8d, 0x29, 0x23,
	0xa1, 0x28, 0xd3, 0x6b, 0x8a, 0xde, 0xd3, 0x82, 0x82, 0xfb, 0x11, 0xf4, 0xec, 0xe8, 0xd6, 0x5d,
	0x87, 0x0f, 0xea, 0x8a, 0xd9, 0x35, 0xb0, 0xa7, 0x51, 0xf7, 0x5f, 0x15, 0xb8, 0x65, 0x63, 0x59,
	0x76, 0xef, 0x73, 0x68, 0x95, 0xaf, 0xe7, 0xdc, 0x7c, 0xbd, 0x32, 0xaf, 0xfc, 0x0c, 0xd5, 0xb7,
	0x3c, 0xc3, 0x8d, 0xa1, 0x5c, 0xff, 0x6f, 0x85, 0xb2, 0xf6, 0x6e, 0xa1, 0xac, 0xff, 0xc7, 0xa1,
	0xdc, 0xb8, 0x2e, 0x94, 0xe8, 0x21, 0xdc, 0x2a, 0x77, 0x29, 0x4b, 0x6e, 0x68, 0x2f, 0x4a, 0x22,
	0xa3, 0xf0, 0xb3, 0xf5, 0x46, 0xa5, 0x5f, 0x75, 0x0f, 0xa0, 0xbf, 0x9f, 0x1b, 0xd2, 0x25, 0xbc,
	0xb2, 0x79, 0x39, 0xab, 0x9b, 0x97, 0xdd, 0x9d, 0x2a, 0xc5, 0xee, 0xe4, 0xfe, 0xb9, 0x0e, 0x70,
	0x70, 0x91, 0x32, 0xc2, 0xb9, 0x8c, 0xc9, 0x09, 0x6c, 0x5e, 0xd9, 0x42, 0x95, 0xa1, 0xee, 0xde,
	0x03, 0x1b, 0xd9, 0x82, 0x3e, 0x7c, 0xba, 0xb2, 0x95, 0x7a, 0xfd, 0xd5, 0x3d, 0x15, 0x3d, 0x86,
	0x7a, 0xb8, 0x08, 0x32, 0x6e, 0xc7, 0xf8, 0xfb, 0xd7, 0x98, 0xd9, 0x57, 0x04, 0xcf, 0x10, 0xb7,
	0xff, 0xee, 0x40, 0x5d, 0x43, 0xe8, 0x09, 0x74, 0x67, 0x49, 0x98, 0x71, 0xdf, 0xdc, 0x42, 0x3a,
	0x23, 0xab, 0x6e, 0xb0, 0x9a, 0x1f, 0x36, 0x06, 0x5e, 0x47, 0xf1, 0x0d, 0xcc, 0xd1, 0x13, 0x68,
	0x31, 0xe9, 0x12, 0x89, 0x48, 0x2c, 0x6c, 0xcd, 0xde, 0xbf, 0xc6, 0x07, 0x2f, 0x67, 0x79, 0x65,
	0x0d, 0x74, 0xac, 0x26, 0xb8, 0x39, 0xea, 0xd6, 0xc8, 0x07, 0x55, 0x65, 0xc6, 0xfd, 0x4e, 0x33,
	0xaa, 0x6b, 0xaa, 0xe9, 0x5d, 0x06, 0xf8, 0xb6, 0x07, 0xbd, 0x15, 0xd2, 0xaa, 0x93, 0xce, 0xbb,
	0x3a, 0xb9, 0xfd, 0x97, 0x0a, 0x40, 0x21, 0x43, 0x5f, 0xcb, 0x35, 0x30, 0xf7, 0x79, 0xb9, 0xc1,
	0xdd, 0x1c, 0xb9, 0xd2, 0x3d, 0x6d, 0x7b, 0x7c, 0x02, 0x1d, 0x9b, 0x50, 0x6f, 0x82, 0x45, 0x66,
	0xdf, 0xf0, 0x46, 0x1b, 0x87, 0x6b, 0x5e, 0xdb, 0x28, 0x7c, 0x23, 0xf9, 0xe8, 0x2b, 0x68, 0xeb,
	0x47, 0x35, 0xfa, 0xd5, 0xb7, 0xe4, 0xc0, 0xe1, 0x9a, 0xd7, 0xd2, 0x0a, 0x5a, 0xff, 0x01, 0xb4,
	0xb9, 0x60, 0x34, 0x9e, 0x1b, 0x7d, 0x35, 0x38, 0x24, 0x49, 0xa3, 0x9a, 0x74, 0x1f, 0x9a, 0x34,
	0xb6, 0x1e, 0xaa, 0xcd, 0x4d, 0x2e, 0x2f, 0x34, 0x16, 0xb9, 0x0d, 0x9c, 0x64, 0xe7, 0x0b, 0xeb,
	0x83, 0x9c, 0x1e, 0x8e, 0xb4, 0xa1, 0x51, 0x45, 0x1a, 0x6f, 0x40, 0x4d, 0x49, 0xdd, 0xcf, 0xa1,
	0xbf, 0x9a, 0xd5, 0x68, 0x13, 0x3a, 0x07, 0xbf, 0x38, 0x9b, 0x7c, 0x33, 0x3a, 0x3a, 0x78, 0x71,
	0xea, 0x9f, 0x1e, 0xf7, 0xd7, 0x50, 0x17, 0x60, 0x7a, 0x36, 0x3e, 0x7d, 0x79, 0x72, 0xe0, 0x1f,
	0x3f, 0xeb, 0x3b, 0xee, 0x2b, 0x40, 0xd3, 0xec, 0x9c, 0x67, 0x91, 0x29, 0xd5, 0x5f, 0x67, 0x84,
	0x0b, 0xb9, 0x88, 0xf2, 0x4b, 0x2e, 0x48, 0x64, 0xc6, 0xb0, 0x39, 0xa1, 0xdb, 0x50, 0x97, 0x9f,
	0x3e, 0x7e, 0x60, 0xa6, 0x68, 0x4d, 0x9e, 0x46, 0x39, 0x7c, 0xae, 0xe2, 0x64, 0xe0, 0xb1, 0xfb,
	0x1b, 0x07, 0x6e, 0x2d, 0x19, 0xe7, 0x69, 0x12, 0x73, 0xb9, 0xd1, 0xd5, 0x19, 0xe1, 0xd9, 0x42,
	0x98, 0x0a, 0xcd, 0xf3, 0xf1, 0x1a, 0xf2, 0xd0, 0x53, 0x4c, 0xcf, 0x68, 0xb8, 0x13, 0xa8, 0x6b,
	0x44, 0xde, 0xa4, 0xb8, 0x5c, 0x7f, 0x0d, 0xb5, 0xa1, 0x31, 0x3d, 0x1b, 0x4f, 0xcf, 0x9e, 0x1f,
	0x4c, 0xfb, 0x0e, 0xea, 0x41, 0xcb, 0x9c, 0x9e, 0xfa, 0xe3, 0x97, 0xfd, 0x0a, 0xea, 0x43, 0xfb,
	0xc5, 0xf1, 0xa9, 0x6f, 0xc1, 0x7e, 0xd5, 0x7d, 0x01, 0xfd, 0x53, 0x16, 0xc4, 0x7c, 0x11, 0x08,
	0x62, 0x2f, 0xfe, 0x96, 0x4e, 0x74, 0x17, 0x9a, 0x7a, 0xd4, 0x17, 0x1b, 0x56, 0x43, 0x03, 0x13,
	0xec, 0xfe, 0xcd, 0x81, 0xcd, 0x92, 0x41, 0x73, 0xd9, 0x4f, 0xdf, 0x36, 0xa9, 0x0f, 0xd7, 0x8a,
	0x21, 0x31, 0x86, 0x7a, 0x14, 0xa4, 0x29, 0xc1, 0x26, 0x61, 0x77, 0x2d, 0xf7, 0x8a, 0xdd, 0xe1,
	0x73, 0xc5, 0xb3, 0x47, 0xb9, 0x2f, 0x6b, 0xcd, 0xed, 0x9f, 0x42, 0x77, 0x59, 0x86, 0x86, 0x50,
	0xa3, 0x82, 0x44, 0x57, 0x7a, 0xd0, 0xea, 0x27, 0x8d, 0xa7, 0x69, 0xe3, 0x86, 0x7d, 0x1f, 0xf7,
	0x1e, 0xb4, 0x4f, 0x02, 0xc6, 0xf3, 0xf0, 0xb4, 0xc1, 0xe1, 0x26, 0x25, 0x1c, 0xee, 0xfe, 0xb6,
	0x0a, 0x9d, 0x29, 0x09, 0x58, 0xf8, 0xba, 0x9c, 0x37, 0x0a, 0xc8, 0xf3, 0x46, 0x9d, 0x6e, 0x1c,
	0x59, 0x95, 0x77, 0x1b, 0x59, 0xd5, 0xeb, 0x47, 0xd6, 0x27, 0xaa, 0xd5, 0xe9, 0xab, 0xf8, 0xfa,
	0x43, 0xc8, 0x2e, 0x16, 0x3d, 0x56, 0xbe, 0x23, 0xe6, 0x7a, 0xdf, 0xba, 0xa0, 0x51, 0x16, 0xf9,
	0xaf, 0xa9, 0xe0, 0xaa, 0xec, 0x6a, 0x72, 0xdf, 0x52, 0xd8, 0x21, 0x15, 0x5c, 0xee, 0xb2, 0x34,
	0x0e, 0x17, 0x19, 0x26, 0x3e, 0x8d, 0xcd, 0xf7, 0x58, 0x5d, 0x7d, 0x8f, 0xf5, 0x0c, 0x3e, 0x31,
	0x30, 0x7a, 0x0c, 0xb5, 0x59, 0xf6, 0xed, 0xb7, 0x7a, 0x6d, 0xeb, 0xee, 0xdd, 0xcd, 0x13, 0xb9,
	0x1c, 0x95, 0xe1, 0x33, 0x49, 0xf1, 0x34, 0x53, 0x7e, 0xea, 0xea, 0x8d, 0x98, 0x60, 0xdf, 0x7e,
	0xa7, 0x70, 0xf3, 0xb3, 0xc0, 0xa6, 0x95, 0xd8, 0x1d, 0x9b, 0xbb, 0x3f, 0x81, 0x9a, 0x52, 0x47,
	0x08, 0xba, 0xcf, 0x46, 0x47, 0x47, 0xe3, 0xd1, 0xfe, 0xcf, 0xfd, 0x67, 0x67, 0xaf, 0x5e, 0xbd,
	0xec, 0xaf, 0xc9, 0x9c, 0x1e, 0x1d, 0xfd, 0x72, 0xf4, 0x72, 0x6a, 0x10, 0x47, 0x16, 0xc1, 0x8b,
	0x63, 0x73, 0xaa, 0xb8, 0xbf, 0x73, 0xa0, 0x6b, 0x5d, 0x31, 0xb9, 0xf0, 0x78, 0x39, 0x17, 0xae,
	0x78, 0x6c, 0xb2, 0xab, 0x94, 0x0e, 0xdb, 0xbf, 0x82, 0x75, 0xf5, 0xc1, 0x6b, 0xc7, 0xb0, 0x53,
	0xfa, 0x09, 0x63, 0xb9, 0x5e, 0x2a, 0xab, 0xf5, 0xf2, 0x21, 0x74, 0x8b, 0xa5, 0x47, 0x29, 0xeb,
	0xf5, 0xba, 0x93, 0xa3, 0xa7, 0x84, 0x45, 0xe3, 0x47, 0x70, 0x2f, 0x4c, 0xa2, 0x21, 0x59, 0x60,
	0x46, 0x2f, 0x86, 0x92, 0x47, 0xe3, 0x64, 0x91, 0xcc, 0x2f, 0x87, 0x51, 0x82, 0xc9, 0x62, 0x5c,
	0x3f, 0x91, 0x9f, 0xce, 0xfc, 0xc4, 0x79, 0x65, 0x7e, 0x2a, 0x3b, 0xaf, 0xab, 0x8f, 0xe9, 0x1f,
	0xfd, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x76, 0xb8, 0xb1, 0x4f, 0x49, 0x13, 0x00, 0x00,
}
